Danh Nguyen
CSCI 4707
Nguy1952



B) 

1.

a. In this schedule, there are conflicts between the following pairs of
transactions: {T1,T2}, {T1,T3}, {T2,T3}.

FALSE

- T1 and T2 does not have conflict. T1 Writes A and C after
T2 has read A and C. This is ok since T2 doesnt modify A,C.

- T3 makes a read before T1 makes a write this is not a conflict.

- T2,T3 They both operate on A but both arent making changes.
Thus no conflict.

b. The schedule is conflict-serializable.

TRUE

The schedule does not form cycles thus and is acyclic therefore
is conflict-serializable.

c. The schedule could be generated by a scheduler using Strict 2PL. In
other words, if we are using Strict 2PL, is the schedule will be the
same?

FALSE

T1 has to obtain a read lock on C before it can get the W lock.



2) Consider the following two transaction
schedules:
(a) R1(X), W2(X), W2(Y), W3(Y), W1(Y), C1, C2, C3
(b) R1(X), W2(Y), W2(X), W3(Y), W1(Y), C1, C2, C3

We will use Strict 2PL with deadlock detection (note: In deadlock
detection, transactions are allowed to wait, they are not aborted until a
deadlock has been detected.) For each sequence, if there is no deadlock,
describe how the concurrency control mechanism handles the sequence
(i.e. state step by step which locks are granted to which transaction, which
transactions block waiting on locks, which transactions commit, etc.). If
there exists deadlocks, draw the wait-for graph.

a)

T1  S(X) R(X)           X(Y) W(Y)  C
T2                                   X(X) W(X) X(Y) W(Y) C
T3          X(Y) W(Y) C 

b) Deadlock

T1 S(X) R(X)                            Wait(Y)
T2          X(Y) W(Y)   Wait(X)
T3                              Wait(Y)












